%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Beamer Presentation
% LaTeX Template
% Version 1.0 (10/11/12)
%
% This template has been downloaded from:
% http://www.LaTeXTemplates.com
%
% License:
% CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass{beamer}

%-------------------------------------------------------------------
%	PACKAGES AND THEMES
%-------------------------------------------------------------------

%%% PACKAGES
\usepackage[utf8]{inputenc}  % italian symbols.
\usepackage[T1]{fontenc}     % define T1 charset for out files.
\usepackage[italian]{babel}  % italian latex typo conventions.
\usepackage{csquotes}        % needed by babel.
\usepackage{amsmath}         % math features.
\usepackage{amsthm}          % math theorems.
\usepackage{amssymb}         % math symbols.
\usepackage{graphicx}        % images managing.
\usepackage{booktabs}        % Allows the use of \toprule, \midrule and \bottomrule in tables
\usepackage{algorithm}       % algorithm block.
\usepackage{algcompatible}
\usepackage{algpseudocode}   % style for (autoimported) package algorithmicx.

%%% MODE
\mode<presentation> {
% The Beamer class comes with a number of default slide themes
% which change the colors and layouts of slides. Below this is a
% list of all the themes, uncomment each in turn to see what they
% look like.

%\usetheme{default}
%\usetheme{AnnArbor}
%\usetheme{Antibes}
%\usetheme{Bergen}        % commented left
%\usetheme{Berkeley}      % menu left
%\usetheme{Berlin}
%\usetheme{Boadilla}      % nice, no top menu
%\usetheme{CambridgeUS}   % nice menu and footer
%\usetheme{Copenhagen}
%\usetheme{Darmstadt}
%\usetheme{Dresden}
%\usetheme{Frankfurt}     % top bullets, no info below
%\usetheme{Goettingen}    % no
%\usetheme{Hannover}      % no
%\usetheme{Ilmenau}       % not bad: bullets, sections, ... but too many rows
%\usetheme{JuanLesPins}   % tree menu
%\usetheme{Luebeck}       % very nice menu
\usetheme{Madrid}        % default
%\usetheme{Malmoe}
%\usetheme{Marburg}
%\usetheme{Montpellier}
%\usetheme{PaloAlto}
%\usetheme{Pittsburgh}    % clean
%\usetheme{Rochester}
%\usetheme{Singapore}     % not bad, no info below
%\usetheme{Szeged}
%\usetheme{Warsaw}

% As well as themes, the Beamer class has a number of color themes
% for any slide theme. Uncomment each of these in turn to see how it
% changes the colors of your current slide theme.

%\usecolortheme{albatross}     % horrible
%\usecolortheme{beaver}        % red blue
%\usecolortheme{beetle}        % horrible
\usecolortheme{crane}         % nice: yellow, orange
%\usecolortheme{dolphin}       % simil default
%\usecolortheme{dove}          % black and white
%\usecolortheme{fly}           % horrible
%\usecolortheme{lily}          % nice, clean blue
%\usecolortheme{orchid}        % like default
%\usecolortheme{rose}          % like default, very good
%\usecolortheme{seagull}       % grey
%\usecolortheme{seahorse}      % light lavanda
%\usecolortheme{whale}         % like default
%\usecolortheme{wolverine}     % yello blue

\usefonttheme{professionalfonts}

% To remove the footer line in all slides uncomment this line
%\setbeamertemplate{footline}

% To replace the footer line in all slides with a simple slide 
% count uncomment this line
%\setbeamertemplate{footline}[page number]

% To remove the navigation symbols from the bottom of all 
% slides uncomment this line
\setbeamertemplate{navigation symbols}{} 

% blocks
%\setbeamertemplate{blocks}[rounded][shadow=true]

} % /mode<presentation>

% top menu
\useoutertheme[subsection=false]{miniframes}

%\setbeamercolor{block title}{use=structure,fg=white,bg=blue!75!black}
%\setbeamercolor{block body}{use=structure,fg=black,bg=white!20!white}

% step by step
\setbeamercovered{transparent}

%%% CONFIGURATIONS
\input{macros}


%-------------------------------------------------------------------
%	TITLE PAGE
%-------------------------------------------------------------------

% The short title appears at the bottom of every slide, 
% the full title is only on the title page
\title[
	\lset{} in Picat
]{
	Progettazione e implementazione
	in Picat di un risolutore per vincoli insiemistici}

\author[Luca \textsc{Parolari}]{
\textit{Candidato:} Luca \textsc{Parolari} \\
\textit{Relatore:} Gianfranco \textsc{Rossi}
}

\institute[UNIPR]
{
	Università di Parma \\
	Dipartimento di Scienze Matematiche Fisiche e Informatiche \\
	Corso di Laurea in Informatica
}
\date{26 settembre 2019}


\begin{document}

\begin{frame}
\titlepage % Print the title page as the first slide
\end{frame}

\begin{frame}
\frametitle{Panoramica della presentazione}
%%% manual toc
%\begin{itemize}
%	\item Il linguaggio \lset{}
%\end{itemize}

%%% automatic toc
\tableofcontents
\end{frame}

%-------------------------------------------------------------------
%	PRESENTATION SLIDES
%-------------------------------------------------------------------

%------------------------------------------------
\section{\lset{}}
%------------------------------------------------

\begin{frame}
  \frametitle{Il linguaggio \lset{}}
  \begin{block}{Definizione (\lset{})}
    \lset{} è un linguaggio basato su vincoli per esprimere e
    risolvere formule del primo ordine sull'universo degli insiemi
    finiti.
  \end{block}
\end{frame}

%------------------------------------------------

\begin{frame}
  \frametitle{Sintassi}
  \begin{block}{Sintassi}
    Insiemi di simboli costituenti di \lset{}:
    \begin{itemize}
    \item $\calF$, insieme di costanti e simboli di funzione;
    \item $\prod_C = \{ =, \in, un, disj, set \}$;
    \item $\calV$, insieme numerabile di varabili.
    \end{itemize}
  \end{block}
  \medskip
  \textbf{Esempi}
  \begin{itemize}
  \item $1$, $a$, $f(\ldots)$, etc.
  \item $un(\cdot, \cdot, \cdot)$, etc.
  \item $A$, $B$, $X$, $Y$, $Var$, etc.
  \end{itemize}
\end{frame}

%------------------------------------------------

\begin{frame}
  \frametitle{Semantica informale}
  \begin{block}{Semantica informale}
    Semantica intuitiva dei simboli in $\Sigma_{\lset}$:
    \begin{itemize}
    \item $\emptyset$ rappresenta l’insieme vuoto;
    \item $\{\cdot\mid\cdot\}$ rappresenta il costruttore di insiemi
      definito come $\{t\mid s\} = \{t\}\ \cup s$;
    \item il predicato $=$ rappresenta la relazione di uguaglianza;
    \item il predicato \textit{in} rappresenta la relazione di
      appartenenza;
    \item il predicato \textit{un} rappresenta la relazione di unione;
      insiemistica definita come: $un(r,s,t) = true
      \Longleftrightarrow t = r \cup s$;
    \item il predicato \textit{disj} rappresenta la relazione di
      disgiunzione insiemistica definita come $disj(r,s) = true
      \Longleftrightarrow r \cap s = \emptyset$;
    \item il predicato \textit{set} controlla che il termine sia un
      insieme.
    \end{itemize}
  \end{block}
\end{frame}

%------------------------------------------------

\begin{frame}
  \frametitle{Esempi} Il linguaggio \lset{} consente di combinare i
  simboli in \lset{}-\textit{termini}, \lset{}-\textit{vincoli} ed
  \lset{}-\textit{formule}.
  \begin{columns}[c]
    \column{.45\textwidth}
    \begin{exampleblock}{Esempio (\lset{}-\textit{termini})}
      \begin{itemize}
      \item $\{1 \mid \emptyset \} \equiv \{1\}$
      \item $\{1 \mid \{2 \mid \emptyset \} \} \equiv \{1,2\}$
      \item $\{1 \mid \{2 \mid X \} \} \equiv \{1,2 \mid X \}$
      \end{itemize}
    \end{exampleblock}
    \begin{exampleblock}{Esempio (\lset{}-\textit{vincoli})}
      \begin{itemize}
      \item $X = 1$
      \item $un(\{1\}, \emptyset, R)$
      \end{itemize}
    \end{exampleblock}
    \column{.45\textwidth}
    \begin{exampleblock}{Esempio (\lset{}-\textit{formule})}
      \begin{itemize}
      \item $1\ in\ R \land 1\ nin\ S \land un(R,S,T) \land T = \{X\}$
      \item $(X\ in\ S \land X\ neq\ 1) \lor (X\ nin\ S \land X = 1)$
      \end{itemize}
    \end{exampleblock}
  \end{columns}
\end{frame}

%------------------------------------------------

\begin{frame}
  \frametitle{Il solver \satset{}}
  % The "c" option specifies centered vertical alignment while the "t"
  % option is used for top vertical alignment
  \begin{columns}[c]

    \column{.5\textwidth} % Left column and width
    %\begin{algorithm}
    %	\caption{Procedura \satset{}}
    \begin{algorithmic}[1]
      \Procedure{\satset{$(C)$}}{}
      \State $C \gets $ \texttt{sort\_infer($C$)};
      \Repeat
      \State $C'$ $\gets C;$
      \Repeat
      \State $C'' \gets C;$
      \State $C \gets $ \texttt{STEP($C$)};
      \Until {$C$ = $C''$;}
      \State $C \gets $ \texttt{remove\_neq($C$)};
      \Until {$C'$ = $C$;}
      \State
      \State\Return $C$;
      \EndProcedure
    \end{algorithmic}
    %	\label{alg:pseudo_satset}
    %\end{algorithm}

    \column{.45\textwidth} % Right column and width
    La procedura \satset{} è la procedura di risoluzione dei vincoli,
    che in \texttt{sort\textunderscore infer} aggiunge i vincoli sui
    tipi, in \texttt{remove\textunderscore neq} rimuove un certo tipo
    di $\neq$-\textit{constraints}, mentre in \texttt{STEP} applica le
    \textbf{regole di riscrittura}.
  \end{columns}
\end{frame}

%------------------------------------------------
\section{Picat}
%------------------------------------------------

\begin{frame}
  \frametitle{Il linguaggio Picat}
  \begin{block}{Picat}
    Picat è un linguaggio di programmazione multiparadigma basato
    sulla logica dei predicati del primo ordine per applicazioni
    \emph{general-purpose}.
  \end{block}
  \medskip
  \textbf{Caratteristiche principali}
  \begin{itemize}
  \item \textbf{P}attern-matching, predicati e funzioni sono definiti
    tramite regole di pattern-matching;
  \item \textbf{I}ntuitive, sono forniti comandi utilizzati nei comuni
    linguaggi imperativi;
  \item \textbf{C}onstraints, la programmazione con vincoli è
    supportata nativamente;
  \item \textbf{A}ctors, viene fornito il supporto per attori
    event-driven;
  \item \textbf{T}abling, viene fornito un sistema di caching per
    la memorizzazione di risultati parziali.
  \end{itemize}
\end{frame}

%------------------------------------------------

\begin{frame}[fragile]
  \frametitle{Esempi (1/2)}
  \begin{exampleblock}{Esempio (Approccio logic programming)}
\begin{verbatim}
fib(0,F) => F=1.
fib(1,F) => F=1.
fib(N,F),N>1 => fib(N-1,F1), fib(N-2,F2), F=F1+F2.
fib(N,F) => throw $error(wrong_argument,fib,N).
\end{verbatim}
  \end{exampleblock}
\end{frame}

%------------------------------------------------

\begin{frame}[fragile]
  \frametitle{Esempi (2/2)}
  \begin{exampleblock}{Esempio (Approccio imperative programming)}
\begin{verbatim}
fib(N,F) =>
    if (N=0; N=1) then
        F=1
    elseif N>1 then
        fib(N-1,F1),fib(N-2,F2),F=F1+F2
    else
        throw $error(wrong_argument,fib,N)
    end.
\end{verbatim}
  \end{exampleblock}
\end{frame}

%------------------------------------------------

\begin{frame}[fragile]
  \frametitle{Picat vs. Prolog}
  \begin{itemize}
  	\item Unificazione e pattern-matching
  	\item Backtracking
  	\item Predicati dinamici
  	\item Operatori definiti da utente
  	\item Costrutti
  \end{itemize}

\end{frame}

%------------------------------------------------

\begin{frame}[fragile]
  \frametitle{Unificazione e pattern-matching}
  Il predicato \texttt{membchk(X, L)} è vero se \texttt{X} è un elemento di \texttt{L}.
  
  \begin{exampleblock}{Esempio (pattern-matching)}
\begin{verbatim}
% Prolog 
membchk(X,[X|_]) :- !.
membchk(X,[_|T]) :- membchk(X,T).

% Picat
membchk(X,[X|_]) => true.
membchk(X,[_|T]) => membchk(X,T).
\end{verbatim}
  \end{exampleblock}
 
  La stessa chiamata \texttt{membchk(X, L)} può avere risultati diversi in Prolog o Picat a seconda che \texttt{X} o \texttt{L} non siano \emph{ground}.
\end{frame}

%------------------------------------------------

\begin{frame}[fragile]
  \frametitle{Backtracking} 
  Il predicato \texttt{member(X, L)} è verso se \texttt{X} è un elemento di \texttt{L}. Se \texttt{X} è una variabile il predicato potrebbe istanziare \texttt{X} a elementi differenti di \texttt{L}.
  
  \begin{exampleblock}{Esempio (Gestione backtracking)}
\begin{verbatim}
% Prolog 
member(X,[X|_]).
member(X,[_|T]) :- member(X,T).

% Picat
member(X,[Y|_]) ?=> X = Y.
member(X,[_|T]) => member(X,T).
\end{verbatim}
  \end{exampleblock}
  In Picat è necessario indicare esplicitamente una regola \emph{backtrackable}.
\end{frame}

%------------------------------------------------

\begin{frame}[fragile]
  \frametitle{Costrutti} 
  Picat fornisce numerosi costrutti built-in.
  \begin{exampleblock}{Esempio (Costrutti)}
\begin{verbatim}
show(List) =>
    I = 1,
    foreach(X in List)
        printf("%s: %s%n", 
               I.to_string(), 
               X.to_string()),
        I := I + 1
    end.
\end{verbatim}
  \end{exampleblock}
\end{frame}


%------------------------------------------------
\section{\lset{} in Picat}
%------------------------------------------------

\begin{frame}
  \frametitle{Linguaggio concreto di input per al solver}
  \begin{itemize}
  	\item Impossibile l'implementazione del linguaggio \lset{} in Picat per via di limitazioni intrinseche del linguaggio
  	\item Adozione di un linguaggio con delle varianti sintattiche per implementazione in Picat
  \end{itemize}
  \begin{table}
    \begin{tabular}{l l l}
      \toprule
        & \textbf{\lset{}} & \textbf{Picat}\\
      \midrule
      \textbf{Formule} & $T_1, \ldots, T_n$ & $[T_1, \ldots, T_n]$ \\
      \textbf{Vincoli} & $T_1 = T_2$ & $eq(T_1, T_2)$ \\
      \textbf{Insiemi} & $\{T_1, \ldots, T_n \mid X\}$ & $[T_1, \ldots, T_n \mid X]$ \\
      \bottomrule
    \end{tabular}
  \caption{Notazione per il linguaggio concreto di input}
  \end{table}
\end{frame}

%------------------------------------------------

\begin{frame}
  \frametitle{Architettura del sistema}
  \begin{itemize}
    \item Architettura a moduli
    \begin{itemize}
      \item solver.pi
      \item commands.pi
      \item lset.pi
      \item global.pi
      \item log\textunderscore h.pi
      \item prompt.pi
      \item assert.pi
    \end{itemize}
	\item Approccio OOP
  \end{itemize}
\end{frame}

%------------------------------------------------

\begin{frame}
	\frametitle{Il solver (1/3)}
	\begin{itemize}
		\item Implementa la procedura decisionale \satset{}
		\item Se la soluzione esiste, deve essere in grado di mostrarle tutte
		\item Riscrive i vincoli fintanto che non è raggiunto il punto fisso
		\item La formula finale ottenuta è semplificata e irriducibile, ovvero equivalente alla formula orginale
	\end{itemize}
\end{frame}

%------------------------------------------------

\begin{frame}[fragile]
  \frametitle{Il solver (2/3)}
  \framesubtitle{Il predicato solve/2}
  
  \begin{columns}[c]
  	\column{0.4\textwidth}
	\begin{itemize}
		\item Interfaccia del solver
		\item Implementa il ciclo che riscrive la formula fino al punto fisso
	\end{itemize}

    \column{0.5\textwidth}  
    \begin{exampleblock}{Esempio (Predicato solve/2)}
\begin{verbatim}
solve(C, CC) =>
    CN = [],
    foreach (T in C)
        sat(T, C1),
        CN := CN ++ C1,
    end,
    CN := CN.flatten(),
    
    if C == CN
    then CC = CN
    else solve(CN, CC)
    end.
\end{verbatim}
    \end{exampleblock}	
  \end{columns}
\end{frame}

%------------------------------------------------

\begin{frame}[fragile]
  \frametitle{Il solver (3/3)}
  \framesubtitle{Il predicato sat/2 e rule/2}	
  
  \begin{columns}[c]
  
    \column{0.4\textwidth}
    \begin{itemize}
      \item Seleziona la regola di riscrittura da applicare
      \item Effettua il dispatching della regola, eseguendola
    \end{itemize}

    \column{0.55\textwidth}  
    \begin{exampleblock}{Esempio (Predicato sat/2)}
\begin{verbatim}
sat(F, FF), F == [] => FR = [].
sat(F, FF) => rule(F, FF).
\end{verbatim}
    \end{exampleblock}	

  \end{columns}

  \begin{exampleblock}{Esempio (Predicato rule/2)}
\begin{verbatim}
rule(eq(T1, T2), R)  => eq(T1, T2, R).
rule(neq(T1, T2), R) => neq(T1, T2, R).
rule(nin(X, S), R)   => nin(X, S, R).
rule(union(S1, S2, S3), R) => union(S1, S2, S3, R).
...
\end{verbatim}
  \end{exampleblock}

\end{frame}

%------------------------------------------------
\section{Implementazione}
%------------------------------------------------

\begin{frame}
  \frametitle{Regole di riscrittura}
  \begin{block}{Definizione (Regola di riscrittura)}
    Se $\pi$ è un simbolo di $\prod$ e $\Phi$ è un \lset{}-\textit{constraint} basato su $\pi$, allora una \emph{regola di riscrittura per $\pi$-constraint} è una regola della forma $\Phi \to \Phi_1 \lor \ldots \lor \Phi_n$, dove $\Phi_i, i \geq 1$ sono \lset{}-formule.
  \end{block}
  \begin{exampleblock}{Esempio (Regola $=_2$)}
  	\[ \text{Se }t \not\in \calV, t = \dotx \to \dotx = t \]
  	
  	il cui risultato pratico è quello di invertire un termine variabile con uno non variabile qualora non siano ``orientati'' correttamente, in pratica:
  	
    \[ 1 = X \to X = 1 \]
  \end{exampleblock}
\end{frame}

%------------------------------------------------

\begin{frame}[fragile]
  \frametitle{Implementazione}
  L'implementazione in Picat è semplice e molto vicina alla descrizione matematica
  \begin{columns}[c]
  	\column{0.45\textwidth}
  	\begin{exampleblock}{Esempio (Desc. matematica)}
  	  Regola $=_2$:
  	  \[
  	    \text{Se }t \not\in \calV, t = \dotx \to \dotx = t 
  	  \]
  	\end{exampleblock}
  
  	\column{0.45\textwidth}
  	\begin{exampleblock}{Esempio (Implementazione)}
\begin{verbatim}
eq(T1, T2, R), 
        nonvar(T1),
        var(T2) =>      % 2
    R = [ $eq(T2, T1) ].
\end{verbatim}
  	\end{exampleblock}
  \end{columns}
\end{frame}

%------------------------------------------------
\section{Uso del solver}
%------------------------------------------------

\begin{frame}[fragile]
  \frametitle{Uso del solver}
  \begin{columns}[c]
    \column{.45\textwidth}
    \textbf{Modalità interattiva}
    \begin{exampleblock}{Esempio (Interprete)}
\begin{verbatim}
log> solve 
[eq(X,1), neq(X,1)]
\end{verbatim}
    \end{exampleblock}

    \column{.45\textwidth}
    \textbf{API}
    \begin{exampleblock}{Esempio (API)}
      Utilizzando il metodo \texttt{solve/2}
\begin{verbatim}
my_predicate =>
    Formula = [ 
        $eq(X,1), 
        $neq(X,1) 
    ],
    solve(Formula, Result),
    println(Result).
\end{verbatim}
    \end{exampleblock}
  \end{columns}
\end{frame}

%------------------------------------------------
\section{Conclusione e sviluppi futuri}
%------------------------------------------------

\begin{frame}
  \frametitle{Conclusioni}
  Il risultato principale di questo lavoro di tesi è stata la progettazione ed implementazione in Picat di un constraint solver per formule insiemistiche.
  
  \bigskip
  
  Per farlo, è stato necessario:
  \begin{itemize}
  	\item sperimentare e capire Picat;
  	\item progettare ed implementare il risolutore di formule stesso.
  \end{itemize}
\end{frame}

%------------------------------------------------

\begin{frame}
  \frametitle{Sviluppi futuri}
  \begin{itemize}
  	\item Aggiungere il supporto alla sintassi nativa di \lset{}
  	\item Arricchire e perfezionare la batteria di test per aumentare la qualità del codice prodotto
  \end{itemize}
\end{frame}

%------------------------------------------------

\begin{frame}
  \Huge{\centerline{Grazie per l'attenzione}}
\end{frame}

%-------------------------------------------------------------------

\end{document}
