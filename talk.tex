\documentclass[11pt]{article}

\usepackage[utf8]{inputenc}  % italian symbols.
\usepackage[T1]{fontenc}     % define T1 charset for out files.
\usepackage[italian]{babel}  % italian latex typo conventions.
\usepackage{csquotes}        % needed by babel.
\usepackage{amsmath}         % math features.
\usepackage{amsthm}          % math theorems.
\usepackage{amssymb}         % math symbols.
\usepackage{hyperref}        % hypertext support.

\title{
	\textbf{Thesis Talk}
	\footnote{\href{https://github.com/lparolari/bachelor-thesis-presentation}{Slides url: https://github.com/lparolari/bachelor-thesis-presentation}}
	\footnote{\href{https://github.com/lparolari/bachelor-thesis}{Thesis url: https://github.com/lparolari/bachelor-thesis}}
	\footnote{\href{https://github.com/lparolari/setlog-picat}{Project url: https://github.com/lparolari/setlog-picat}}
}
\author{Luca Parolari\footnote{\href{mailto:luca.parolari23@gmail.com}{luca.parolari23@gmail.com}}}
\date{26/09/2019}

\input{macros}

\begin{document}

\maketitle

L'obiettivo del lavoro di tesi che vi presento oggi è la progettazione
e l'implementazione di un risolutore di formule per vincoli
insiemistici.

In questa presentazione voglio dare una breve panoramica del
linguaggio \lset{}, il linguaggio utilizzato per la gestione di
vincoli insiemistici derivato da \clpset{}. Successivamente presenterò
Picat, il linguaggio ospite sul quale è stato implementato il solver,
per poi passare alla descrizione delle scelte effettuate nella
realizzazione del solver e del suo sistema, problemi incontrati ed
implementazione delle regole di riscrittura, componenti fondamentali
del solver tramite i quali è stato possibile risolvere i vincoli. Si
darà poi un accenno all'utilizzo del solver per concludere con la
considerazioni finali ed i lavori futuri.

\lset{} è un linguaggio basato su vincoli per esprimere e risolvere
formule del primo ordine sull'universo degli insiemi finiti. E' stato
inizialmente concepito come un parte del linguaggio logico basato su
vincoli (CLP) \clpset{}. Fondamentalmente, \lset{} fornisce una forma
molto generale di insiemi, letteralmente ``insiemi ibridi finiti
ereditari non tipizzati'' (mi sono esercitato a casa a dirla in
inglese, senza successo, di conseguenza ve la propongo in
italiano). Gli insiemi finiti ereditari possono essere altri inisemi
finiti ereditari; mentre gli insiemi ibridi sono insiemi i cui
elementi possono essere oggetti di tipo non insiemistico. L'utilizzo
combinato di queste due categorie di insiemi da vita ad una forma
molto generale di insieme, dove uno o più elementi dell'insieme
possono essere variabili. Questi insiemi sono manipolati dagli usuali
operatori su insiemi (come ad esempio l'eguaglianza tra insiemi,
appartenza, unione, eccetera) che sono forniti sottoforma di
vincoli. Più in particolare, l'uguaglianza tra insiemi è implementata
con l'unificazione insiemistica, mentre il soddisfacimento dei vincoli
è verificato da un solver completo tramite una procedura di decisione
per formule di \lset{} (questo solver è appunto l'oggetto oggetto di
questo lavoro).

Vediamo rapidamente la sintassi di questo linguaggio: possiamo notare
che è denotata da insiemi piuttosto semplici, abbiamo un insieme
finito $\calF$ di costanti e di simboli di funzione non interpretati
come $1, a, f(1,2), ...$, l'insieme dei predicati come appunto $=$,
unione, disgiunzione... e l'insieme delle variabili $\calV$.

La semantica invece è piuttosto intuitiva: abbiamo l'insieme vuoto, il
costruttore di insiemi che ci permette appunto di creare insiemi da un
singoletto $t$ unito ad un resto $s$ e i predicati con relativa
semantica.

Il linguaggio consente di combinare gli insiemi precedentemente
mostrati in termini, vincoli o formule. Di particolare importanza sono
le formule, che non sono altro che congiunzioni o disgiunzioni di
termini e vincoli.

Lo pseudocodice mostrato in figura è la procedure di risoluzione per
vincoli insiemistici adottata dal solver. Questa procedura sfrutta
principalente tre sotto procedure: la più importante è STEP, ovvero la
procedura che applica le regole di riscrittura ai vincoli generandone
di nuovi, possibilemnte più semplici dei precedenti.  Come evidenziato
dai test dei cicli, la procedura termina quando viene raggiunto un
punto fisso, ovvero non è più possibile trovare nuovi vincoli più
semplici dei precedenti.

Esistono già diverse implementazioni di \lset{}, come ad esempio
setlog scritto in prolog o JSetL per Java. In questo contesto è stato
sperimentato Picat per l'implementazione di \lset{}. Picat è un
linguaggio di programmazione multiparadigna basato sulla logica dei
predicati del primo ordine, per applicazioni general purpose. Picat
prende il nome dai suoi punti di forza. Senza scendere in dettagli
tecnici, Picat si propone come un linguaggio basato su pattern
matching, ovvero le regole applcabili ad una certa chiamata vengono
selezionate tramite il pattern matching, intuitivo fornendo costrutti
comunemente utilizzati in linguaggi imperativi, il supporto nativo
della programmazione con vincoli, il supporto alla programmazione di
attori event-driven e il supporto di meccanismi di caching.  Voglio
accentuare soprattutto la I (Intuitive) in quanto soprattutto per
l'ambito dei linguaggi logici capita spesso che programmi di
medie/grandi dimensioni siano piuttosto difficili da capire e da
manutenere. In Picat questo problema cerca di essere affrontato con
costrutti che richiamano la programmazione OOP come ad esempio i
moduli, le funzioni, la notazione oggetto punto metodo... Vediamo
quindi un esempio: qui è mostrato come Picat può essere un normale
linguaggio logico con predicati, chiamate ricorsive, eccetera, mentre
in quest'altro esempio vediamo come è possibile adottare uno stile di
programmazione più imperativo.

Non mi soffermo di troppo sugli esempi perché sono solo a scopo
dimostrativo.

Voglio invece spendere qualche parola sulle differenze tra Picat e
Prolog, il suo rivale. Le differenze tra i due linguaggi non sono
poche e nemmeno trascurabli. Visto che ci sono degli esempi nelle
slide successive per unificazione, backtracking e costrutti partirei
dai predicati dinamici, che a Picat mancano: non è possibile asserire
predicati durante l'esecuzione. Ciò rende Picat meno flessibile
rispetto al Prolog, ma anche meno soggetto a bug. Anche gli operatori
non possono essere definiti dall'utente in Picat: questo è un grosso
punto a sfavore perché ad esempio per il linguaggio \lset{} sarebbe
stato molto naturale definire degli operatori per rappresentare i
vincoli. Un'altra differenza tra i due linguaggi è l'unificazione ed
il pattern matching. In picat viene utilizzato il pattern matching per
decidere quale regola applicare, mentre in prolog si utilizza sempre
l'unificazione. Ciò porta ad alcune divergenze nell'esecuzione di
predicati simili, ad esempio questo [indicare con il dito]. Anche sul
backtracking trovaimo qualche discrepanza. In prolog tutti i predicati
sono backtrackabili, ed il cotrollo è effettuato con il cut. In Picat
invece è possibile definire la backtrackabilità specificandolo nella
testa del predicato. Un'altra differenza forte tra i due linguaggi
sono i costrutti: Picat offre una serie di costrutti che permettono al
programmatore l'utilizzo di funzionalità che vengono dal mondo della
programmazione imperativa. Spesso semplificano il codice soprattutto
per programmi di scripting.

TODO

\end{document}
